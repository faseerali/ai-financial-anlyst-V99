import { Component, ChangeDetectionStrategy, signal, inject, ViewChild, ElementRef, effect, computed, HostListener } from '@angular/core';
import { CommonModule } from '@angular/common';
import { GeminiService, FinancialAnalysis, RatioCategory, AnalystView, TrendAnalysis, RatioTrendAnalysis } from './services/gemini.service';
import { Chart } from 'chart.js/auto';

declare var jspdf: any;
declare var html2canvas: any;

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [CommonModule],
  providers: [GeminiService],
})
export class AppComponent {
  private geminiService = inject(GeminiService);

  // Manager View Charts
  @ViewChild('profitabilityChart') profitabilityChartRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('incomeStatementChart') incomeStatementChartRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('balanceSheetAssetsChart') balanceSheetAssetsChartRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('balanceSheetLiabilitiesChart') balanceSheetLiabilitiesChartRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('cashFlowChart') cashFlowChartRef!: ElementRef<HTMLCanvasElement>;

  // Analyst View Charts
  @ViewChild('trendsChart') trendsChartRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('expenseChart') expenseChartRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('varianceChart') varianceChartRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('ratiosChart') ratiosChartRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('waterfallChart') waterfallChartRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('ratioTrendsChart') ratioTrendsChartRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('breakevenChart') breakevenChartRef!: ElementRef<HTMLCanvasElement>;

  // Slideshow and Actions Menu
  @ViewChild('actionsMenu') actionsMenuRef!: ElementRef;
  @ViewChild('slideshowCanvas') slideshowCanvasRef!: ElementRef<HTMLCanvasElement>;

  fileName = signal<string | null>(null);
  fileContent = signal<string | null>(null);
  isLoading = signal(false);
  error = signal<string | null>(null);
  analysisResult = signal<FinancialAnalysis | null>(null);
  activeView = signal<'manager' | 'analyst'>('manager');
  activeStatementTab = signal<'income' | 'balance' | 'cashflow'>('income');

  // Signals for multi-outlet support
  outlets = signal<string[]>([]);
  selectedOutlet = signal<string | null>(null);

  // Signals for interactive forecast
  revenueGrowthRate = signal(5);
  expenseGrowthRate = signal(2);
  isUpdatingForecast = signal(false);

  // Signals for Actions and Slideshow
  isActionsMenuOpen = signal(false);
  isSlideshowOpen = signal(false);
  currentSlideIndex = signal(0);
  slides = signal<any[]>([]);

  // Signals for Analyst View Time Filtering
  analystTimeFilter = signal<'monthly' | 'quarterly' | 'yearly'>('monthly');

  // Signals for AI Query
  aiQuery = signal('');
  aiQueryAnswer = signal<string | null>(null);
  isQueryingAI = signal(false);
  aiQueryError = signal<string | null>(null);
  suggestedQuestions = [
    'What is the current ratio?',
    'Show me the revenue trend for the last year.',
    'What was the biggest expense category?',
    'Summarize the cash flow from operations.'
  ];

  canShowQuarterlyFilter = computed(() => {
    const result = this.analysisResult();
    const labels = result?.analystView?.trendAnalysis?.labels;
    return labels && labels.length >= 3;
  });

  canShowYearlyFilter = computed(() => {
      const result = this.analysisResult();
      const labels = result?.analystView?.trendAnalysis?.labels;
      return labels && labels.length >= 12;
  });

  allRatios = computed(() => {
    const result = this.analysisResult();
    if (!result || !result.ratios) {
      return [];
    }
    return result.ratios.flatMap(category => category.ratios);
  });

  financialGlossary = [
    {
      term: 'Revenue',
      definition: 'The total amount of income generated by the sale of goods or services related to the company\'s primary operations.'
    },
    {
      term: 'Cost of Goods Sold (COGS)',
      definition: 'The direct costs of producing the goods sold by a company. This amount includes the cost of the materials and labor directly used to create the good.'
    },
    {
      term: 'Gross Profit',
      definition: 'The profit a company makes after deducting the costs associated with making and selling its products. It is calculated as Revenue - COGS.'
    },
    {
      term: 'Operating Expenses (OpEx)',
      definition: 'Expenses a business incurs through its normal business operations that are not directly related to production, such as rent, utilities, and marketing.'
    },
    {
      term: 'Net Income (or Net Profit)',
      definition: 'A company\'s total earnings (or profit). Net income is calculated by taking revenues and subtracting the costs of doing business such as COGS, operating expenses, interest, and taxes.'
    },
    {
      term: 'Current Ratio',
      definition: 'A liquidity ratio that measures a company\'s ability to pay short-term obligations or those due within one year. Formula: Current Assets / Current Liabilities.'
    },
    {
      term: 'Debt-to-Equity Ratio',
      definition: 'A solvency ratio that measures a company\'s financial leverage. It indicates how much debt a company is using to finance its assets relative to the value of shareholders\' equity. Formula: Total Liabilities / Shareholders\' Equity.'
    },
    {
      term: 'Net Profit Margin',
      definition: 'A profitability ratio that measures how much net income is generated as a percentage of revenue. Formula: (Net Income / Revenue) * 100.'
    }
  ];

  private profitabilityChart: Chart | null = null;
  private incomeStatementChart: Chart | null = null;
  private balanceSheetAssetsChart: Chart | null = null;
  private balanceSheetLiabilitiesChart: Chart | null = null;
  private cashFlowChart: Chart | null = null;

  private trendsChart: Chart | null = null;
  private expenseChart: Chart | null = null;
  private varianceChart: Chart | null = null;
  private ratiosChart: Chart | null = null;
  private waterfallChart: Chart | null = null;
  private ratioTrendsChart: Chart | null = null;
  private breakevenChart: Chart | null = null;

  private slideshowChart: Chart | null = null;
  
  @HostListener('document:click', ['$event'])
  onDocumentClick(event: MouseEvent) {
      if (this.isActionsMenuOpen() && this.actionsMenuRef && !this.actionsMenuRef.nativeElement.contains(event.target)) {
          this.isActionsMenuOpen.set(false);
      }
  }

  @HostListener('document:keydown', ['$event'])
  handleKeyboardEvent(event: KeyboardEvent) {
      if (this.isSlideshowOpen()) {
          if (event.key === 'Escape') {
              this.closeSlideshow();
          } else if (event.key === 'ArrowRight') {
              this.nextSlide();
          } else if (event.key === 'ArrowLeft') {
              this.prevSlide();
          }
      }
  }
  
  constructor() {
    // Main view chart rendering effect
    effect(() => {
      const result = this.analysisResult();
      const view = this.activeView();
      const tab = this.activeStatementTab();
      const filter = this.analystTimeFilter();

      Promise.resolve().then(() => {
        if (!result) {
          this.destroyCharts();
          return;
        }

        if (view === 'manager') {
          this.destroyAnalystCharts();
          if (this.profitabilityChartRef && !this.profitabilityChart) {
            this.profitabilityChart = this.createProfitabilityChart(result, this.profitabilityChartRef);
          }
          
          this.destroyStatementCharts();
          
          switch (tab) {
            case 'income':
              if (this.incomeStatementChartRef) this.incomeStatementChart = this.createIncomeStatementChart(result, this.incomeStatementChartRef);
              break;
            case 'balance':
              if (this.balanceSheetAssetsChartRef && this.balanceSheetLiabilitiesChartRef) {
                this.balanceSheetAssetsChart = this.createBalanceSheetDoughnut(result, 'assets', this.balanceSheetAssetsChartRef);
                this.balanceSheetLiabilitiesChart = this.createBalanceSheetDoughnut(result, 'liabilitiesAndEquity', this.balanceSheetLiabilitiesChartRef);
              }
              break;
            case 'cashflow':
              if (this.cashFlowChartRef) this.cashFlowChart = this.createCashFlowChart(result, this.cashFlowChartRef);
              break;
          }

        } else if (view === 'analyst') {
            this.destroyManagerCharts();
            const filteredAnalystView = this.getFilteredAnalystView(result.analystView, filter);

            // Update or create filterable charts for smoother transitions
            if (this.trendsChart) {
                this.updateTrendsChart(this.trendsChart, filteredAnalystView?.trendAnalysis);
            } else if (this.trendsChartRef) {
                this.trendsChart = this.createTrendsChart({ ...result, analystView: filteredAnalystView }, this.trendsChartRef);
            }

            if (this.ratioTrendsChart) {
                this.updateRatioTrendsChart(this.ratioTrendsChart, filteredAnalystView?.ratioTrendAnalysis);
            } else if (this.ratioTrendsChartRef) {
                this.ratioTrendsChart = this.createRatioTrendsChart({ ...result, analystView: filteredAnalystView }, this.ratioTrendsChartRef);
            }
          
            // Create other non-filterable charts only if they don't exist yet
            if (this.expenseChartRef && !this.expenseChart) this.expenseChart = this.createExpenseChart(result, this.expenseChartRef);
            if (this.varianceChartRef && !this.varianceChart) this.varianceChart = this.createVarianceChart(result, this.varianceChartRef);
            if (this.ratiosChartRef && !this.ratiosChart) this.ratiosChart = this.createRatiosChart(result, this.ratiosChartRef);
            if (this.waterfallChartRef && !this.waterfallChart) this.waterfallChart = this.createWaterfallChart(result, this.waterfallChartRef);
            if (this.breakevenChartRef && !this.breakevenChart) this.breakevenChart = this.createBreakevenChart(result, this.breakevenChartRef);
        }
      });
    });

    // Slideshow chart rendering effect
    effect(() => {
        const isOpen = this.isSlideshowOpen();
        const slideIndex = this.currentSlideIndex();
        
        if (!isOpen) {
            this.destroySlideshowChart();
            return;
        }

        const result = this.analysisResult();
        const slide = this.slides()[slideIndex];

        Promise.resolve().then(() => {
            this.destroySlideshowChart();
            if (result && slide && slide.type === 'chart' && this.slideshowCanvasRef) {
                this.slideshowChart = this.createSlideshowChart(result, slide.chartName);
            }
        });
    });
  }

  onFileSelected(event: Event): void {
    const input = event.target as HTMLInputElement;
    const file = input.files?.[0];
    
    if (!file) {
        return;
    }

    const MAX_FILE_SIZE_BYTES = 5 * 1024 * 1024; // 5 MB
    if (file.size > MAX_FILE_SIZE_BYTES) {
        this.error.set(`File is too large. Please select a file smaller than ${MAX_FILE_SIZE_BYTES / 1024 / 1024}MB.`);
        this.fileName.set(null);
        this.fileContent.set(null);
        input.value = '';
        return;
    }
    
    this.error.set(null);
    this.fileName.set(file.name);

    const reader = new FileReader();
    reader.onload = (e) => {
        this.fileContent.set(e.target?.result as string);
    };
    reader.onerror = () => {
        this.error.set('Failed to read the file.');
    };
    reader.readAsText(file);
  }

  async analyzeData(): Promise<void> {
    const content = this.fileContent();
    if (!content) {
      this.error.set('Please select a file first.');
      return;
    }

    this.isLoading.set(true);
    this.error.set(null);
    this.analysisResult.set(null);
    this.destroyCharts();
    this.outlets.set([]);
    this.selectedOutlet.set(null);

    try {
      // First, get outlets to see if we need to show the filter
      const detectedOutlets = await this.geminiService.getOutlets(content);
      this.outlets.set(detectedOutlets);

      // Now run the initial analysis (consolidated view)
      const result = await this.geminiService.analyzeFinancialData(content, null); // null for consolidated view
      this.analysisResult.set(result);
    } catch (err) {
      console.error('Analysis failed:', err);
      this.error.set('An error occurred during analysis. Please check if the uploaded file is a properly formatted CSV and try again. If the issue persists, the AI model may be temporarily unavailable.');
    } finally {
      this.isLoading.set(false);
    }
  }

  async changeOutlet(event: Event): Promise<void> {
    const outlet = (event.target as HTMLSelectElement).value;
    const content = this.fileContent();
    
    if (!content) return;
    
    const outletForAnalysis = outlet === 'all' ? null : outlet;
    this.selectedOutlet.set(outletForAnalysis);

    this.isLoading.set(true);
    this.error.set(null);
    this.analysisResult.set(null);
    this.destroyCharts();

    // Reset view-specific states
    this.activeView.set('manager');
    this.activeStatementTab.set('income');
    this.analystTimeFilter.set('monthly');

    try {
      const result = await this.geminiService.analyzeFinancialData(content, outletForAnalysis);
      this.analysisResult.set(result);
    } catch (err) {
      console.error(`Analysis for outlet ${outlet} failed:`, err);
      this.error.set(`An error occurred during analysis for ${outlet}. Please try again.`);
    } finally {
      this.isLoading.set(false);
    }
  }

  reset(): void {
    this.fileName.set(null);
    this.fileContent.set(null);
    this.analysisResult.set(null);
    this.error.set(null);
    this.isLoading.set(false);
    this.destroyCharts();
    this.activeView.set('manager');
    this.activeStatementTab.set('income');
    this.analystTimeFilter.set('monthly');
    this.aiQuery.set('');
    this.aiQueryAnswer.set(null);
    this.isQueryingAI.set(false);
    this.aiQueryError.set(null);
    this.outlets.set([]);
    this.selectedOutlet.set(null);
  }

  setActiveView(view: 'manager' | 'analyst'): void {
    this.activeView.set(view);
  }

  setActiveStatementTab(tab: 'income' | 'balance' | 'cashflow'): void {
    this.activeStatementTab.set(tab);
  }

  setAnalystTimeFilter(filter: 'monthly' | 'quarterly' | 'yearly'): void {
    this.analystTimeFilter.set(filter);
  }

  onRevenueGrowthChange(event: Event): void {
    const value = (event.target as HTMLInputElement).value;
    this.revenueGrowthRate.set(Number(value));
  }

  onExpenseGrowthChange(event: Event): void {
      const value = (event.target as HTMLInputElement).value;
      this.expenseGrowthRate.set(Number(value));
  }

  async updateForecast(): Promise<void> {
      const content = this.fileContent();
      if (!content) {
          return;
      }

      this.isUpdatingForecast.set(true);
      try {
          const newForecast = await this.geminiService.getUpdatedForecast(
              content,
              this.revenueGrowthRate(),
              this.expenseGrowthRate()
          );

          this.analysisResult.update(currentResult => {
              if (!currentResult) return null;
              return {
                  ...currentResult,
                  analystView: {
                      ...currentResult.analystView,
                      forecast: newForecast,
                  },
              };
          });
      } catch (err) {
          console.error('Forecast update failed:', err);
      } finally {
          this.isUpdatingForecast.set(false);
      }
  }

  // --- AI Query Methods ---

  onAiQueryChange(event: Event): void {
    this.aiQuery.set((event.target as HTMLInputElement).value);
  }

  async askAi(): Promise<void> {
    const content = this.fileContent();
    const query = this.aiQuery();
    if (!content || !query.trim()) {
        return;
    }

    this.isQueryingAI.set(true);
    this.aiQueryAnswer.set(null);
    this.aiQueryError.set(null);
    try {
        const answer = await this.geminiService.queryData(content, query);
        this.aiQueryAnswer.set(answer);
    } catch (err) {
        if (err instanceof Error) {
            this.aiQueryError.set(err.message);
        } else {
            this.aiQueryError.set('An unknown error occurred while asking the AI.');
        }
        console.error('AI query failed:', err);
    } finally {
        this.isQueryingAI.set(false);
    }
  }

  askSuggestedQuestion(question: string): void {
    this.aiQuery.set(question);
    this.askAi();
  }

  // --- Export, Print, Slideshow Methods ---

  async exportAsPDF(): Promise<void> {
    this.isActionsMenuOpen.set(false);
    const content = document.getElementById('print-section');
    if (content) {
      try {
        const { jsPDF } = jspdf;
        const canvas = await html2canvas(content, {
          scale: 2,
          useCORS: true,
          backgroundColor: window.matchMedia('(prefers-color-scheme: dark)').matches ? '#111827' : '#ffffff',
        });
        const imgData = canvas.toDataURL('image/png');
        const pdf = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
        let heightLeft = pdfHeight;
        let position = 0;
        pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, pdfHeight);
        heightLeft -= pdf.internal.pageSize.getHeight();
        while (heightLeft >= 0) {
          position = heightLeft - pdfHeight;
          pdf.addPage();
          pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, pdfHeight);
          heightLeft -= pdf.internal.pageSize.getHeight();
        }
        pdf.save(`${this.fileName()?.replace(/\.[^/.]+$/, "") || 'financial-report'}.pdf`);
      } catch (error) {
        console.error('Error generating PDF:', error);
        this.error.set('Could not generate PDF.');
      }
    }
  }

  printReport(): void {
    this.isActionsMenuOpen.set(false);
    window.print();
  }

  startSlideshow(): void {
    this.isActionsMenuOpen.set(false);
    this.populateSlides();
    this.currentSlideIndex.set(0);
    this.isSlideshowOpen.set(true);
  }

  closeSlideshow(): void {
    this.isSlideshowOpen.set(false);
    this.destroySlideshowChart();
  }

  nextSlide(): void {
    if (this.currentSlideIndex() < this.slides().length - 1) {
      this.currentSlideIndex.update(i => i + 1);
    }
  }

  prevSlide(): void {
    if (this.currentSlideIndex() > 0) {
      this.currentSlideIndex.update(i => i - 1);
    }
  }

  private populateSlides(): void {
    const result = this.analysisResult();
    if (!result) return;
    const newSlides: any[] = [
      { title: 'Financial Analysis Report', type: 'title', data: this.fileName() },
      { title: 'Executive Summary & Key Risks', type: 'summary_risks', data: { summary: result.executiveSummary, risks: result.keyRisks } },
      { title: 'Income Statement', type: 'table', data: result.incomeStatement },
      { title: 'Balance Sheet', type: 'table', data: result.balanceSheet },
      { title: 'Cash Flow Statement', type: 'table', data: result.cashFlowStatement },
    ];

    result.ratios.forEach(category => {
        newSlides.push({ title: `${category.category} Ratios`, type: 'kpi_category', data: category });
    });

    newSlides.push(
      { title: 'Profitability Trend', type: 'chart', chartName: 'profitability' },
      { title: 'Revenue vs. Expenses Trend', type: 'chart', chartName: 'trends' },
      { title: 'Expense Breakdown', type: 'chart', chartName: 'expense' },
      { title: 'Cash Flow Waterfall', type: 'chart', chartName: 'waterfall' },
      { title: 'Key Ratio Trends', type: 'chart', chartName: 'ratioTrends' },
      { title: 'Key Ratios Overview', type: 'chart', chartName: 'ratios' },
      { title: 'Variance Analysis (Budget vs. Actual)', type: 'chart', chartName: 'variance' },
      { title: 'Breakeven Analysis', type: 'chart', chartName: 'breakeven' },
    );
    this.slides.set(newSlides);
  }

  private createSlideshowChart(data: FinancialAnalysis, chartName: string): Chart | null {
    if (!this.slideshowCanvasRef) return null;
    switch (chartName) {
      case 'profitability': return this.createProfitabilityChart(data, this.slideshowCanvasRef);
      case 'trends': return this.createTrendsChart(data, this.slideshowCanvasRef);
      case 'expense': return this.createExpenseChart(data, this.slideshowCanvasRef);
      case 'waterfall': return this.createWaterfallChart(data, this.slideshowCanvasRef);
      case 'ratioTrends': return this.createRatioTrendsChart(data, this.slideshowCanvasRef);
      case 'ratios': return this.createRatiosChart(data, this.slideshowCanvasRef);
      case 'variance': return this.createVarianceChart(data, this.slideshowCanvasRef);
      case 'breakeven': return this.createBreakevenChart(data, this.slideshowCanvasRef);
      default: return null;
    }
  }

    // --- Data Aggregation for Filtering ---
    private getAggregatedLabel(chunkLabels: string[], filter: 'quarterly' | 'yearly'): string {
        if (!chunkLabels || chunkLabels.length === 0) return '';
        const firstLabel = chunkLabels[0];
        
        const yearMatch = firstLabel.match(/\b(20\d{2})\b/);
        const year = yearMatch ? yearMatch[0] : '';

        if (filter === 'yearly') {
            return year || firstLabel;
        }

        const monthMatch = firstLabel.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i);
        if (monthMatch) {
            const monthStr = monthMatch[0].toLowerCase();
            const months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            const monthIndex = months.indexOf(monthStr);
            if (monthIndex > -1) {
                const quarter = Math.floor(monthIndex / 3) + 1;
                return `Q${quarter} ${year}`.trim();
            }
        }
        
        if (chunkLabels.length > 1) {
            return `${firstLabel} - ${chunkLabels[chunkLabels.length - 1]}`;
        }
        return firstLabel;
    }

    private getFilteredAnalystView(analystView: AnalystView | undefined, filter: 'monthly' | 'quarterly' | 'yearly'): AnalystView | undefined {
        if (!analystView || filter === 'monthly' || !analystView.trendAnalysis?.labels?.length) {
            return analystView;
        }

        const aggregationPeriod = filter === 'quarterly' ? 3 : 12;
        const originalTrendAnalysis = analystView.trendAnalysis;
        const newTrendAnalysis: TrendAnalysis = { ...originalTrendAnalysis, labels: [], revenueData: [], expenseData: [], netIncomeData: [] };

        for (let i = 0; i < originalTrendAnalysis.labels.length; i += aggregationPeriod) {
            const chunkLabels = originalTrendAnalysis.labels.slice(i, i + aggregationPeriod);
            if (chunkLabels.length === 0) continue;
            
            newTrendAnalysis.labels.push(this.getAggregatedLabel(chunkLabels, filter));
            const sumReducer = (acc: number, val: number) => acc + val;
            newTrendAnalysis.revenueData.push(originalTrendAnalysis.revenueData.slice(i, i + aggregationPeriod).reduce(sumReducer, 0));
            newTrendAnalysis.expenseData.push(originalTrendAnalysis.expenseData.slice(i, i + aggregationPeriod).reduce(sumReducer, 0));
            newTrendAnalysis.netIncomeData.push(originalTrendAnalysis.netIncomeData.slice(i, i + aggregationPeriod).reduce(sumReducer, 0));
        }

        const originalRatioAnalysis = analystView.ratioTrendAnalysis;
        const newRatioAnalysis: RatioTrendAnalysis = { ...originalRatioAnalysis, labels: [], datasets: originalRatioAnalysis.datasets.map(ds => ({ ...ds, data: [] }))};

        for (let i = 0; i < originalRatioAnalysis.labels.length; i += aggregationPeriod) {
            const chunkLabels = originalRatioAnalysis.labels.slice(i, i + aggregationPeriod);
            if (chunkLabels.length === 0) continue;
            
            newRatioAnalysis.labels.push(this.getAggregatedLabel(chunkLabels, filter));
            const avgReducer = (arr: number[]) => arr.length ? arr.reduce((acc, val) => acc + val, 0) / arr.length : 0;
            
            originalRatioAnalysis.datasets.forEach((dataset, index) => {
                const chunkData = dataset.data.slice(i, i + aggregationPeriod);
                newRatioAnalysis.datasets[index].data.push(avgReducer(chunkData));
            });
        }

        return {
            ...analystView,
            trendAnalysis: newTrendAnalysis,
            ratioTrendAnalysis: newRatioAnalysis
        };
    }

  // --- Chart Update Methods ---
  private updateTrendsChart(chart: Chart, trendAnalysis: TrendAnalysis | undefined): void {
    if (!chart || !trendAnalysis?.labels) return;
    chart.data.labels = trendAnalysis.labels;
    chart.data.datasets[0].data = trendAnalysis.revenueData;
    chart.data.datasets[1].data = trendAnalysis.expenseData;
    chart.update();
  }
  
  private updateRatioTrendsChart(chart: Chart, ratioTrendAnalysis: RatioTrendAnalysis | undefined): void {
    if (!chart || !ratioTrendAnalysis?.labels) return;
    chart.data.labels = ratioTrendAnalysis.labels;

    const lineColors = ['#818cf8', '#34d399', '#f59e0b', '#ef4444', '#3b82f6'];
    const newDatasets = ratioTrendAnalysis.datasets.map((dataset, index) => ({
        ...dataset, // copy existing properties
        borderColor: lineColors[index % lineColors.length], 
        backgroundColor: `${lineColors[index % lineColors.length]}1A`, 
        fill: true, 
        tension: 0.4,
    }));

    chart.data.datasets = newDatasets;
    chart.update();
  }

  // --- Chart Creation Methods ---
  
  private getChartOptions() {
    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
    const textColor = isDarkMode ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
    const tooltipBackgroundColor = isDarkMode ? '#1f2937' : '#ffffff';
    const tooltipTitleColor = isDarkMode ? '#f9fafb' : '#111827';
    const tooltipBodyColor = isDarkMode ? '#d1d5db' : '#374151';

    const currencyTooltip = {
        callbacks: {
            label: (context: any) => {
                let label = context.dataset.label || '';
                if (label) {
                    label += ': ';
                }
                if (context.parsed.y !== null) {
                    label += new Intl.NumberFormat('en-AE', { style: 'currency', currency: 'AED' }).format(context.parsed.y);
                } else if (context.parsed !== null) {
                    label += new Intl.NumberFormat('en-AE', { style: 'currency', currency: 'AED' }).format(context.parsed);
                }
                return label;
            }
        }
    };

    return { gridColor, textColor, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor, currencyTooltip, isDarkMode }
  }

  private createProfitabilityChart(data: FinancialAnalysis, canvasRef: ElementRef): Chart | null {
    const { gridColor, textColor, currencyTooltip, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor } = this.getChartOptions();
    if (data.analystView?.trendAnalysis?.labels?.length > 0) {
        const ctx = canvasRef.nativeElement.getContext('2d');
        if (ctx) {
            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.analystView.trendAnalysis.labels,
                    datasets: [
                        { type: 'line', label: 'Net Income', data: data.analystView.trendAnalysis.netIncomeData, borderColor: '#818cf8', backgroundColor: 'rgba(129, 140, 248, 0.1)', yAxisID: 'y', fill: true, tension: 0.4, },
                        { type: 'bar', label: 'Revenue', data: data.analystView.trendAnalysis.revenueData, backgroundColor: 'rgba(52, 211, 153, 0.7)', borderColor: '#34d399', yAxisID: 'y', borderRadius: 4, },
                    ],
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, grid: { color: gridColor }, ticks: { color: textColor, callback: (value) => 'AED ' + (Number(value) / 1000) + 'k' } },
                        x: { grid: { display: false }, ticks: { color: textColor } }
                    },
                    plugins: {
                        legend: { labels: { color: textColor }, position: 'bottom' },
                        tooltip: { ...currencyTooltip, backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor, borderColor: gridColor, borderWidth: 1 }
                    }
                },
            });
        }
    }
    return null;
  }

  private createIncomeStatementChart(data: FinancialAnalysis, canvasRef: ElementRef): Chart | null {
      const { gridColor, textColor, currencyTooltip, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor } = this.getChartOptions();
      if (data.incomeStatementChartData?.labels?.length > 0) {
          const ctx = canvasRef.nativeElement.getContext('2d');
          if (ctx) {
              return new Chart(ctx, {
                  type: 'bar',
                  data: {
                      labels: data.incomeStatementChartData.labels,
                      datasets: [{
                          label: 'Amount', data: data.incomeStatementChartData.data,
                          backgroundColor: ['rgba(52, 211, 153, 0.7)', 'rgba(248, 113, 113, 0.7)', 'rgba(59, 130, 246, 0.7)', 'rgba(251, 146, 60, 0.7)', 'rgba(99, 102, 241, 0.7)'],
                          borderRadius: 4,
                      }]
                  },
                  options: {
                      responsive: true, maintainAspectRatio: false,
                      scales: {
                          y: { beginAtZero: true, grid: { color: gridColor }, ticks: { color: textColor, callback: (value) => 'AED ' + (Number(value) / 1000) + 'k' } },
                          x: { grid: { display: false }, ticks: { color: textColor } }
                      },
                      plugins: {
                          legend: { display: false },
                          tooltip: { ...currencyTooltip, backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor, borderColor: gridColor, borderWidth: 1 }
                      }
                  }
              });
          }
      }
      return null;
  }

  private createBalanceSheetDoughnut(data: FinancialAnalysis, type: 'assets' | 'liabilitiesAndEquity', canvasRef: ElementRef): Chart | null {
      const { textColor, currencyTooltip, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor, isDarkMode } = this.getChartOptions();
      const chartData = data.balanceSheetChartData?.[type];
      if (chartData?.labels?.length > 0) {
          const ctx = canvasRef.nativeElement.getContext('2d');
          if (ctx) {
              return new Chart(ctx, {
                  type: 'doughnut',
                  data: {
                      labels: chartData.labels,
                      datasets: [{
                          data: chartData.data,
                          backgroundColor: type === 'assets' ? ['#22d3ee', '#60a5fa', '#818cf8'] : ['#f87171', '#fb923c', '#4ade80'],
                          borderColor: isDarkMode ? '#1f2937' : '#ffffff', borderWidth: 2, hoverOffset: 4
                      }]
                  },
                  options: {
                      responsive: true, maintainAspectRatio: false,
                      plugins: {
                          legend: { position: 'right' as const, labels: { color: textColor } },
                          tooltip: { ...currencyTooltip, backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor },
                          title: { display: true, text: type === 'assets' ? 'Assets' : 'Liabilities & Equity', color: textColor }
                      }
                  }
              });
          }
      }
      return null;
  }

  private createCashFlowChart(data: FinancialAnalysis, canvasRef: ElementRef): Chart | null {
      const { gridColor, textColor, currencyTooltip, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor } = this.getChartOptions();
      if (data.cashFlowChartData?.labels?.length > 0) {
          const ctx = canvasRef.nativeElement.getContext('2d');
          if (ctx) {
              return new Chart(ctx, {
                  type: 'bar',
                  data: {
                      labels: data.cashFlowChartData.labels,
                      datasets: [{
                          label: 'Amount', data: data.cashFlowChartData.data,
                          backgroundColor: data.cashFlowChartData.data.map(v => v >= 0 ? 'rgba(52, 211, 153, 0.7)' : 'rgba(248, 113, 113, 0.7)'),
                          borderRadius: 4,
                      }]
                  },
                  options: {
                      responsive: true, maintainAspectRatio: false,
                      scales: {
                          y: { beginAtZero: true, grid: { color: gridColor }, ticks: { color: textColor, callback: (value) => 'AED ' + (Number(value) / 1000) + 'k' } },
                          x: { grid: { display: false }, ticks: { color: textColor } }
                      },
                      plugins: {
                          legend: { display: false },
                          tooltip: { ...currencyTooltip, backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor, borderColor: gridColor, borderWidth: 1 }
                      }
                  }
              });
          }
      }
      return null;
  }
  
  private createTrendsChart(data: FinancialAnalysis, canvasRef: ElementRef): Chart | null {
    const { gridColor, textColor, currencyTooltip, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor } = this.getChartOptions();
    if (data.analystView?.trendAnalysis?.labels?.length > 0) {
        const ctx = canvasRef.nativeElement.getContext('2d');
        if (ctx) {
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.analystView.trendAnalysis.labels,
                    datasets: [
                        { label: 'Revenue', data: data.analystView.trendAnalysis.revenueData, borderColor: '#34d399', backgroundColor: 'rgba(52, 211, 153, 0.1)', fill: true, tension: 0.4 },
                        { label: 'Expenses', data: data.analystView.trendAnalysis.expenseData, borderColor: '#f87171', backgroundColor: 'rgba(248, 113, 113, 0.1)', fill: true, tension: 0.4 },
                    ],
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, grid: { color: gridColor }, ticks: { color: textColor, callback: (value) => 'AED ' + (Number(value) / 1000) + 'k' }, title: { display: true, text: 'Amount (AED)', color: textColor } },
                        x: { grid: { color: gridColor }, ticks: { color: textColor }, title: { display: true, text: 'Period', color: textColor } }
                    },
                    plugins: {
                        legend: { labels: { color: textColor } },
                        tooltip: { ...currencyTooltip, backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor, borderColor: gridColor, borderWidth: 1, }
                    }
                },
            });
        }
    }
    return null;
  }

  private createExpenseChart(data: FinancialAnalysis, canvasRef: ElementRef): Chart | null {
    const { isDarkMode, gridColor, textColor, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor } = this.getChartOptions();
    if (data.analystView?.expenseBreakdown?.labels?.length > 0) {
        const ctx = canvasRef.nativeElement.getContext('2d');
        if (ctx) {
            return new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: data.analystView.expenseBreakdown.labels,
                    datasets: [{
                        data: data.analystView.expenseBreakdown.data,
                        backgroundColor: ['#f87171', '#fb923c', '#facc15', '#a3e635', '#4ade80', '#34d399', '#22d3ee', '#60a5fa', '#818cf8', '#c084fc'],
                        borderColor: isDarkMode ? '#1f2937' : '#ffffff', borderWidth: 2, hoverOffset: 4,
                    }],
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'right', labels: { color: textColor } },
                        tooltip: {
                            callbacks: {
                                label: (context: any) => {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const sum = context.dataset.data.reduce((a: number, b: number) => a + b, 0);
                                    const percentage = sum > 0 ? ((value / sum) * 100).toFixed(2) + '%' : '0.00%';
                                    return `${label}: ${new Intl.NumberFormat('en-AE', { style: 'currency', currency: 'AED' }).format(value)} (${percentage})`;
                                }
                            },
                            backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor, borderColor: gridColor, borderWidth: 1,
                        }
                    }
                },
            });
        }
    }
    return null;
  }

  private createVarianceChart(data: FinancialAnalysis, canvasRef: ElementRef): Chart | null {
      const { gridColor, textColor, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor } = this.getChartOptions();
      const varianceData = data.analystView?.varianceAnalysis;
      if (varianceData?.labels?.length > 0) {
        const ctx = canvasRef.nativeElement.getContext('2d');
        if (ctx) {
            const percentageVarianceData = varianceData.actualData.map((actual, index) => {
                const budget = varianceData.budgetData[index];
                return (budget === 0 || !budget) ? 0 : ((actual - budget) / budget) * 100;
            });

            return new Chart(ctx, {
              type: 'bar',
              data: {
                labels: varianceData.labels,
                datasets: [
                  { label: 'Actual', data: varianceData.actualData, backgroundColor: 'rgba(79, 70, 229, 0.7)', borderColor: '#4f46e5', borderRadius: 6, yAxisID: 'y' },
                  { label: 'Budget', data: varianceData.budgetData, backgroundColor: 'rgba(100, 116, 139, 0.7)', borderColor: '#64748b', borderRadius: 6, yAxisID: 'y' },
                  { label: 'Variance %', data: percentageVarianceData, type: 'line', borderColor: '#f59e0b', backgroundColor: 'rgba(245, 158, 11, 0.2)', yAxisID: 'y1', tension: 0.4, pointRadius: 4, pointBackgroundColor: '#f59e0b' },
                ],
              },
              options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                  y: { beginAtZero: true, type: 'linear', position: 'left', grid: { color: gridColor }, ticks: { color: textColor, callback: (value) => 'AED ' + Number(value) / 1000 + 'k' }, title: { display: true, text: 'Amount (AED)', color: textColor } },
                  y1: { type: 'linear', position: 'right', grid: { display: false }, ticks: { color: textColor, callback: (value) => `${value}%` }, title: { display: true, text: 'Variance (%)', color: textColor } },
                  x: { grid: { display: false }, ticks: { color: textColor }, title: { display: true, text: 'Category', color: textColor } },
                },
                plugins: {
                  legend: { labels: { color: textColor } },
                  tooltip: {
                    backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor, borderColor: gridColor, borderWidth: 1,
                    callbacks: {
                      label: (context: any) => {
                        let label = context.dataset.label || '';
                        if (label) { label += ': '; }
                        if (context.parsed.y !== null) {
                          label += context.dataset.label === 'Variance %' ? context.parsed.y.toFixed(2) + '%' : new Intl.NumberFormat('en-AE', { style: 'currency', currency: 'AED' }).format(context.parsed.y);
                        }
                        return label;
                      },
                    },
                  },
                },
              },
            });
        }
    }
    return null;
  }
    
  private createRatiosChart(data: FinancialAnalysis, canvasRef: ElementRef): Chart | null {
    const { gridColor, textColor, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor } = this.getChartOptions();
    const allRatiosData = this.allRatios();
    if (allRatiosData.length > 0) {
        const ctx = canvasRef.nativeElement.getContext('2d');
        if (ctx) {
            return new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: allRatiosData.map(r => r.name),
                    datasets: [{
                        label: 'Ratio Value',
                        data: allRatiosData.map(r => { const num = parseFloat(r.value.replace(/[^0-9.-]+/g,"")); return isNaN(num) ? 0 : num; }),
                        fill: true, backgroundColor: 'rgba(129, 140, 248, 0.2)', borderColor: '#818cf8', pointBackgroundColor: '#818cf8', pointBorderColor: '#fff', pointHoverBackgroundColor: '#fff', pointHoverBorderColor: '#818cf8',
                    }],
                },
                options: { 
                    responsive: true, maintainAspectRatio: false,
                    scales: { r: { angleLines: { color: gridColor }, grid: { color: gridColor }, pointLabels: { color: textColor, font: { size: 12 } }, ticks: { color: textColor, backdropColor: 'rgba(0,0,0,0)' } } },
                     plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (tooltipItems: any[]) => tooltipItems.length > 0 ? tooltipItems[0].label || '' : '',
                                label: (context: any) => `Value: ${allRatiosData[context.dataIndex]?.value || ''}`
                            },
                            backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor, borderColor: gridColor, borderWidth: 1,
                        }
                    }
                },
            });
        }
    }
    return null;
  }

  private createWaterfallChart(data: FinancialAnalysis, canvasRef: ElementRef): Chart | null {
    const { gridColor, textColor, currencyTooltip, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor } = this.getChartOptions();
    const waterfallSrc = data.analystView?.waterfallAnalysis;
    if (waterfallSrc?.labels?.length > 0) {
        const ctx = canvasRef.nativeElement.getContext('2d');
        if (ctx) {
            const waterfallLabels: string[] = [], waterfallData: [number, number][] = [], backgroundColors: string[] = [];
            let runningTotal = 0;
            const colors = { increment: 'rgba(52, 211, 153, 0.7)', decrement: 'rgba(239, 68, 68, 0.7)', total: 'rgba(99, 102, 241, 0.7)', finalTotal: 'rgba(79, 70, 229, 0.8)' };

            const revenue = waterfallSrc.data[0] || 0;
            waterfallLabels.push(waterfallSrc.labels[0] || 'Revenue'); waterfallData.push([0, revenue]); backgroundColors.push(colors.increment); runningTotal = revenue;
            const cogs = -Math.abs(waterfallSrc.data[1] || 0);
            if (cogs !== 0) { waterfallLabels.push(waterfallSrc.labels[1] || 'COGS'); waterfallData.push([runningTotal + cogs, runningTotal]); backgroundColors.push(colors.decrement); runningTotal += cogs; }
            waterfallLabels.push('Gross Profit'); waterfallData.push([0, runningTotal]); backgroundColors.push(colors.total);
            const opEx = -Math.abs(waterfallSrc.data[2] || 0);
            if (opEx !== 0) { waterfallLabels.push(waterfallSrc.labels[2] || 'Operating Expenses'); waterfallData.push([runningTotal + opEx, runningTotal]); backgroundColors.push(colors.decrement); runningTotal += opEx; }
            waterfallLabels.push('Net Income'); waterfallData.push([0, runningTotal]); backgroundColors.push(colors.finalTotal);

            return new Chart(ctx, {
                type: 'bar',
                data: { labels: waterfallLabels, datasets: [{ data: waterfallData, backgroundColor: backgroundColors, barPercentage: 0.8 }] },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, grid: { color: gridColor }, ticks: { color: textColor, callback: (value) => 'AED ' + (Number(value) / 1000) + 'k' } },
                        x: { grid: { display: false }, ticks: { color: textColor } }
                    },
                    plugins: { legend: { display: false }, tooltip: { ...currencyTooltip, backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor, borderColor: gridColor, borderWidth: 1 } }
                }
            });
        }
    }
    return null;
  }
  
  private createRatioTrendsChart(data: FinancialAnalysis, canvasRef: ElementRef): Chart | null {
    const { gridColor, textColor, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor } = this.getChartOptions();
    const ratioTrendsData = data.analystView?.ratioTrendAnalysis;
    if (ratioTrendsData?.labels?.length > 0) {
        const ctx = canvasRef.nativeElement.getContext('2d');
        if (ctx) {
            const lineColors = ['#818cf8', '#34d399', '#f59e0b', '#ef4444', '#3b82f6'];
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ratioTrendsData.labels,
                    datasets: ratioTrendsData.datasets.map((dataset, index) => ({
                        label: dataset.label, data: dataset.data, borderColor: lineColors[index % lineColors.length], backgroundColor: `${lineColors[index % lineColors.length]}1A`, fill: true, tension: 0.4,
                    })),
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: false, grid: { color: gridColor }, ticks: { color: textColor }, title: { display: true, text: 'Ratio Value', color: textColor, } },
                        x: { grid: { color: gridColor }, ticks: { color: textColor }, title: { display: true, text: 'Period', color: textColor, } }
                    },
                    plugins: {
                        legend: { labels: { color: textColor } },
                        tooltip: {
                            backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor, borderColor: gridColor, borderWidth: 1,
                             callbacks: {
                                label: (context: any) => {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) {
                                        const value = context.parsed.y;
                                        label += (label.toLowerCase().includes('margin') || label.toLowerCase().includes('%')) ? value.toFixed(2) + '%' : value.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                },
            });
        }
    }
    return null;
  }

  private createBreakevenChart(data: FinancialAnalysis, canvasRef: ElementRef): Chart | null {
    const { gridColor, textColor, currencyTooltip, tooltipBackgroundColor, tooltipTitleColor, tooltipBodyColor } = this.getChartOptions();
    const breakevenData = data.analystView?.breakevenAnalysis;
    if (breakevenData?.currentRevenueValue && breakevenData?.breakevenRevenueValue) {
        const ctx = canvasRef.nativeElement.getContext('2d');
        if (ctx) {
            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [''],
                    datasets: [
                        { label: 'Current Revenue', data: [breakevenData.currentRevenueValue], backgroundColor: 'rgba(52, 211, 153, 0.7)', borderColor: '#34d399', borderRadius: 4, barPercentage: 0.6 },
                        { label: 'Breakeven Revenue', data: [breakevenData.breakevenRevenueValue], backgroundColor: 'rgba(248, 113, 113, 0.7)', borderColor: '#f87171', borderRadius: 4, barPercentage: 0.6 }
                    ],
                },
                options: {
                    indexAxis: 'y',
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: { beginAtZero: true, grid: { color: gridColor }, ticks: { color: textColor, callback: (value) => 'AED ' + (Number(value) / 1000) + 'k' } },
                        y: { grid: { display: false }, ticks: { display: false } }
                    },
                    plugins: {
                        legend: { position: 'bottom', labels: { color: textColor } },
                        tooltip: { ...currencyTooltip, backgroundColor: tooltipBackgroundColor, titleColor: tooltipTitleColor, bodyColor: tooltipBodyColor, borderColor: gridColor, borderWidth: 1 }
                    }
                },
            });
        }
    }
    return null;
  }

  // --- Chart Destruction Methods ---

  private destroyManagerCharts(): void {
    this.profitabilityChart?.destroy();
    this.profitabilityChart = null;
    this.destroyStatementCharts();
  }

  private destroyStatementCharts(): void {
    this.incomeStatementChart?.destroy();
    this.balanceSheetAssetsChart?.destroy();
    this.balanceSheetLiabilitiesChart?.destroy();
    this.cashFlowChart?.destroy();
    this.incomeStatementChart = null;
    this.balanceSheetAssetsChart = null;
    this.balanceSheetLiabilitiesChart = null;
    this.cashFlowChart = null;
  }

  private destroyAnalystCharts(): void {
    this.trendsChart?.destroy();
    this.expenseChart?.destroy();
    this.varianceChart?.destroy();
    this.ratiosChart?.destroy();
    this.waterfallChart?.destroy();
    this.ratioTrendsChart?.destroy();
    this.breakevenChart?.destroy();
    this.trendsChart = null;
    this.expenseChart = null;
    this.varianceChart = null;
    this.ratiosChart = null;
    this.waterfallChart = null;
    this.ratioTrendsChart = null;
    this.breakevenChart = null;
  }

  private destroySlideshowChart(): void {
    this.slideshowChart?.destroy();
    this.slideshowChart = null;
  }

  private destroyCharts(): void {
    this.destroyManagerCharts();
    this.destroyAnalystCharts();
    this.destroySlideshowChart();
  }
}